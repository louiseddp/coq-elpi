
namespace derive.eqbcorrect {

pred main i:inductive, i:string, o:list prop.
main I Prefix CLs :- std.do! [
  % Add error msg if not a inductive ?
  coq.env.indt I _ _ N TI Ks KTs,

  induction-db I Indu,
  mk-reali (global (indt I)) IR, % param1-db, really
 
  /* Correctness */
coq.say "0" I,
  std.map2 KTs Ks (add-decl-correct Prefix N (global (indt I))) Lt-correct,
coq.say "1",
  add-indu-correct TI (global (indt I)) Indu IR Lt-correct R,
coq.say "2",

  std.assert-ok! (coq.typecheck R Ty) "derive.eqbcorrect: add-indu-correct generates ill typed term", 
  coq.say "R =" {coq.term->string R}, 
  Name is Prefix ^ "eqb_correct",
  coq.env.add-const Name R Ty @opaque! Correct,
 
  add-indu-correct-aux TI (global (indt I)) Indu IR Lt-correct Rx,
  std.assert-ok! (coq.typecheck Rx Tyx) "derive.eqbcorrect: add-indu-correct-aux generates ill typed term", 
  Namex is Prefix ^ "eqb_correct_aux",
/*  coq.say "Rx =" {coq.term->string Rx}, */
  coq.env.add-const Namex Rx Tyx @opaque! Correctx,
 
  /* Refl */
  std.map2 KTs Ks (add-decl-refl Prefix N (global (indt I))) Lt-refl, 
 
  add-indu-refl TI (global (indt I)) Indu IR Lt-refl Rr,
  std.assert-ok! (coq.typecheck Rr Tyr) "derive.eqbcorrect: add-indu-refl generates ill typed term", 
  Namer is Prefix ^ "eqb_refl",
  coq.env.add-const Namer Rr Tyr @opaque! Refl,

  add-indu-refl-aux TI (global (indt I)) Indu IR Lt-refl Rrx,
  std.assert-ok! (coq.typecheck Rrx Tyrx) "derive.eqbcorrect: add-indu-refl-aux generates ill typed term", 
  Namerx is Prefix ^ "eqb_refl_aux",
  coq.env.add-const Namerx Rrx Tyrx @opaque! Reflx,

  /* Add the clauses in the database */
  CLs = [
    eqcorrect-for I Correct Refl,
    correct-lemma-for (global (indt I)) (global (const Correctx)),
    refl-lemma-for (global (indt I)) (global (const Reflx)), 
  ],

  std.forall CLs (x\coq.elpi.accumulate _ "derive.eqbcorrect.db" (clause _ _ x)),

].

pred run-solver i:sealed-goal, i:string.
run-solver G Name :-
  if (coq.ltac.open (coq.ltac.call Name []) G []) true
     (@holes! => coq.sealed-goal->string G SG,
      std.fatal-error {calc ( "solver " ^ Name ^ " fails on goal:\n" ^ SG )}).

pred coq.sealed-goal->string i:sealed-goal, o:string.
coq.sealed-goal->string (nabla G) R :- pi x\  coq.sealed-goal->string (G x) R.
coq.sealed-goal->string (seal (goal Ctx _ Ty _ _)) R :-
  Ctx => (std.map {std.rev Ctx} coq.ctx->string L, coq.term->string Ty G, R is "Lemma foo " ^ {std.string.concat "\n" L} ^ "\n :\n" ^ G ^ ".").

pred coq.ctx->string i:prop, o:string.
coq.ctx->string (decl X _ Ty) R :- R is "(" ^ {coq.term->string X} ^ " : " ^ {coq.term->string Ty} ^ ")".
coq.ctx->string (def X _ Ty B) R :- R is "(" ^ {coq.term->string X} ^ " : " ^ {coq.term->string Ty} ^ " := " ^ {coq.term->string B} ^ ")".

/************************** correct *********************************************/

pred what-for i:(term -> term -> prop), i:(term -> term -> prop), i:term, o:term.

% (is_option (seq A) (is_seq A (eqb_correrct A eqA) =>
%  eqb_correrct (option (seq A)) 
pred eqb-correct-aux-for i:term, o:term.

eqb-correct-aux-for T R :-
  what-for correct-lemma-for eqb-correct-aux-for T R.

eqb-correct-aux-for T R :- whd1 T T1, !, eqb-correct-aux-for T1 R.

eqb-correct-aux-for {{ _ = true }} {{ fun x px => I }}.

pred eqb-refl-aux-for i:term, o:term.
eqb-refl-aux-for T R :- whd1 T T1, !, eqb-refl-aux-for T1 R.

eqb-refl-aux-for T R :-
  what-for refl-lemma-for eqb-refl-aux-for T R.

what-for What Rec (app [GR | L] as GRL) R :- !, std.do! [
  /* coq.safe-dest-app GRL GR L, */
  What GR Aux,
  mk-reali GR (global (indt ISGR)),
  param1-functor-for ISGR Funct,
  std.map L Rec Recs,
  apply-functor (global Funct) Recs TOTO,
  apply-aux Aux L Aux1, 
  what-for-app GRL Aux1 TOTO R
].

/* what-for-app GRL Aux1 TOTO {{ fun (x:lp:GRL) H => lp:Aux1 x H }} :-
  coq.typecheck TOTO (prod N T x\ (prod _ T1 _\ T2)) _,
  coq.say "T1 =" {coq.term->string T1},
  coq.say "T2 =" {coq.term->string T2},
  T1 = T2. */

pred what-for-app i:term, i:term, i:term, o:term.
what-for-app GRL Aux1 TOTO {{ fun (x:lp:GRL) H => lp:Aux1 x (lp:TOTO x H) }}.

what-for What _Rec GR R :- std.do! [ % ???
  What GR Aux,
  R = {{ fun (x:lp:GR) H => lp:Aux x H }}
].

pred apply-aux i:term, i:list term, o:term.
apply-aux Aux [] Aux.
apply-aux Aux [T|L] Aux1 :- !, std.do![
  mk-eqb-for T EQB,
  apply-aux {{ lp:Aux lp:T lp:EQB }} L Aux1
].

pred apply-functor i:term, i:list term, o:term.
apply-functor X [] X.
apply-functor X [R|RS] TOTO :- apply-functor {{ lp:X _ _ _ lp:R }} RS TOTO.

pred add-decl-correct i:string, i:int, i:term, i:term, i:constructor, o:term.
add-decl-correct _Prefix N I KT K R /*(global (const P))*/ :- std.do![  
  do-params-correct N I KT (global (indc K)) R,
  std.assert-ok! (coq.typecheck R _Ty) {coq.term->string R}, %"R case", /* FIXME: is it needed ? */ 
].

pred mk-reali i:term, o:term.
mk-reali T R :- !,
  % coq.say "REALI" {coq.term->string T},
  std.assert! (reali T R) {calc (
    "derive.eqbcorrect: no unary parametricity translation for " ^ {coq.term->string T} ^ ", use derive.param1 first")}.

pred mk-eqb-for i:term, o:term.
mk-eqb-for T R :- !,
  std.assert! (eqb-for T R) {calc (
    "derive.eqbcorrect: boolean equality for " ^ {coq.term->string T} ^ ", maybe use derive.eqb first")}.

pred is-a-type i:term.
is-a-type (sort (typ _)).
is-a-type (sort prop) :- coq.error "derive.eqb: parameters in Prop are not supported".
is-a-type T :- whd1 T T1, is-a-type T1.

pred do-params-correct i:int, i:term, i:term, i:term, o:term.
do-params-correct 0 I T K R :- !, 
  mk-eqb-for I Cmp,
  reali I {{ @eqb_correct_on lp:I lp:Cmp }} =>    
  eqb-correct-aux-for I {{ fun x H => H }} => 
  do-args-correct T K R.

do-params-correct NP I (prod N T F) K {{ fun (a : lp:T) (eqA : a -> a -> bool) => lp:(R a eqA) }} :- NP > 0, is-a-type T, !, NP1 is NP - 1,
  @pi-decl N T a\
  @pi-decl `eqA` {{ lp:a -> lp:a -> bool }} eqA\
  eqb-for a eqA =>
  eqb-correct-aux-for a {{ fun (x: lp:a) (H : @eqb_correct_on lp:a lp:eqA x) => H }} => 
  reali a {{ @eqb_correct_on lp:a lp:eqA }} =>
    do-params-correct NP1 {coq.mk-app I [a]} (F a) {{ lp:K lp:a }} (R a eqA).

do-params-correct NP I (prod N T F) K {{ fun (a : lp:T) => lp:(R a) }} :- NP > 0, !, NP1 is NP - 1,
  reali T IsT,
  std.spy(param1-inhab-db IsT IsT_inhab),
  @pi-decl N T a\
    reali a {{ lp:IsT_inhab lp:a }} =>
    do-params-correct NP1 {coq.mk-app I [a]} (F a) {{ lp:K lp:a }} (R a).

/*
pred do-args-correct i:term, i:term, o:term.
do-args-correct (prod N T F) K {{ fun (x : lp:T) (px : lp:EqbOn x) (h : @eqb_correct_on lp:T lp:Cmp x := lp:View x px) => lp:(R x px h) }} :- !, std.do! [
  mk-reali T EqbOn,
  mk-eqb-for T Cmp, 
  eqb-correct-aux-for T View, 
  @pi-decl N T x\
  @pi-decl `px` {{ lp:EqbOn lp:x }} px\
  /* FIXME: introduce the let only if EqbOn <> {{ @eqb_correct_on lp:T lp:Cmp }} */
  @pi-def `H` {{ @eqb_correct_on lp:T lp:Cmp lp:x }} {{ lp:View lp:x lp:px }} h\
         do-args-correct (F x) {{ lp:K lp:x }} (R x px h)
]. */

pred do-args-correct i:term, i:term, o:term.

do-args-correct (prod N ( {{ _ = true }} as T) F) K {{ fun (x : lp:T) (useless : lp:EqbOn x) => lp:(R x useless) }} :- !, std.do! [
  mk-reali T EqbOn,
  mk-eqb-for T Cmp, 
  @pi-decl N T x\
  @pi-decl `px` {{ lp:EqbOn lp:x }} px\
  do-args-correct-body (F x) T EqbOn x px {{ fun _ => True }} {{ lp:K lp:x }} (R x px)
]. 

do-args-correct (prod N T F) K {{ fun (x : lp:T) (px : lp:EqbOn x) => lp:(R x px) }} :- !, std.do! [
  mk-reali T EqbOn,
  mk-eqb-for T Cmp, 
  @pi-decl N T x\
  @pi-decl `px` {{ lp:EqbOn lp:x }} px\
  reali x px =>
  do-args-correct-body (F x) T EqbOn x px {{ @eqb_correct_on lp:T lp:Cmp }} {{ lp:K lp:x }} (R x px)
]. 

do-args-correct T K {{ lp:B : eqb_correct_on lp:Cmp lp:K }} :- std.do! [
  mk-eqb-for T Cmp,
  coq.safe-dest-app T (global (indt I)) Args,
  fields-for I _ _ _ ConstructPC,
  coq.mk-app (global (const ConstructPC)) Args ConstructP,
  eqb-fields T Fields,
  B = {{ @eqb_body_correct _ _ _ _ _ lp:ConstructP lp:Fields lp:K (fun f => _) }},
  coq.typecheck {{ lp:B : eqb_correct_on lp:Cmp lp:K }} _ _,
  coq.ltac.collect-goals B [G] _,
  run-solver G "eqb_correct_on__solver",
].

% PX : _EqbOn X
% View X PX : EqbOn' X
pred do-args-correct-body i:term, i:term, i:term, i:term, i:term, i:term, i:term, o:term.
do-args-correct-body F T _EqbOn X PX EqbOn' K {{ let h : lp:EqbOn' lp:X := lp:View lp:X lp:PX in lp:(R h) }} :- !, std.spy-do! [
/*  coq.say "EqbOn =" {coq.term->string EqbOn},
   coq.say "EqbOn' =" {coq.term->string EqbOn'}, */
  eqb-correct-aux-for T View, 
  @pi-def `H` {{ lp:EqbOn' lp:X }} {{ lp:View lp:X lp:PX }} h\
    do-args-correct F K  (R h)
].




/*
pred do-args-correct i:term, i:term, o:term.
do-args-correct (prod N T F) K {{ fun (x : lp:T) (px : lp:EqbOn x) => lp:(Body x px) }} :- !, std.do! [
  mk-reali T EqbOn,  coq.say {coq.term->string EqbOn},
  mk-eqb-for T Cmp, 
  @pi-decl N T x\
  @pi-decl `px` {{ lp:EqbOn lp:x }} px\
  if (EqbOn = {{ @eqb_correct_on lp:T lp:Cmp }}) 
    (do-args-correct (F x) {{ lp:K lp:x }} (Body x px))
    (eqb-correct-aux-for T View,!,
     @pi-def `H` {{ @eqb_correct_on lp:T lp:Cmp lp:x }} {{ lp:View lp:x lp:px }} h\
         do-args-correct (F x) {{ lp:K lp:x }} (R x px h),
         Body = {{ let h : @eqb_correct_on lp:T lp:Cmp lp:x := lp:View lp:x lp:px in lp:(R x px h) }})
].
*/

 

pred add-indu-correct i:term, i:term, i:term, i:term, i:list term, o:term.
add-indu-correct (prod N T F) I Indu IR LS 
     {{ fun (a : lp:T) (eqA : a -> a -> bool) (eqAc : eqb_correct eqA) => lp:(R a eqA eqAc) }} :- !,
  @pi-decl N T a\
  @pi-decl `eqA` {{ lp:a -> lp:a -> bool }} eqA\
  @pi-decl `eqAc` {{ @eqb_correct lp:a lp:eqA }} eqAc\ % super nasty "bug", the _ does not see a, if you write lp:{{ FOO a }} it works. Elaborating the skeleton is also ok, but then param1-inhab-db does not work well :-/
  param1-inhab-db {{ @eqb_correct_on lp:a lp:eqA }} eqAc =>
  eqb-for a eqA =>
  add-indu-correct (F a) 
     { coq.mk-app I [a] }
     {{ lp:Indu lp:a (@eqb_correct_on lp:a lp:eqA)}} 
     {{ lp:IR lp:a (@eqb_correct_on lp:a lp:eqA)}} 
     {std.map LS (t\coq.mk-app t [a, eqA])} (R a eqA eqAc).

add-indu-correct _T I Indu IR LS {{ fun x => lp:(R x) }} :- std.do![
  std.assert! (param1-inhab-db IR Is_full) "not trivially inhabited",
  mk-eqb-for I Cmp, 
  @pi-decl `x` _ x\
    std.append LS [x, app[Is_full,x]] (Args x),
    R x = app [Indu, {{ @eqb_correct_on lp:I lp:Cmp }} | Args x]
]. 
  
pred add-indu-correct-aux i:term, i:term, i:term, i:term, i:list term, o:term.
add-indu-correct-aux (prod N T F) I Indu IR LS {{ fun (a : lp:T) (eqA : a -> a -> bool) => lp:(R a eqA) }} :- !,
  @pi-decl N T a\
  @pi-decl `eqA` {{ lp:a -> lp:a -> bool }} eqA\
  eqb-for a eqA =>
  add-indu-correct-aux (F a) 
     { coq.mk-app I [a] }
     {{ lp:Indu lp:a (@eqb_correct_on lp:a lp:eqA)}} 
     {{ lp:IR lp:a (@eqb_correct_on lp:a lp:eqA)}} 
     {std.map LS (t\coq.mk-app t [a, eqA])} (R a eqA).

add-indu-correct-aux _T I Indu _IR LS R :- 
  mk-eqb-for I Cmp, 
  R = app [Indu, {{ @eqb_correct_on lp:I lp:Cmp }} | LS].


/******************************** Refl **************************************************************/
pred add-decl-refl i:string, i:int, i:term, i:term, i:constructor, o:term.
add-decl-refl _Prefix N I KT K R /*(global (const P))*/ :- std.do![  
  do-params-refl N I KT (global (indc K)) R,
  std.assert-ok! (coq.typecheck R _Ty) "R casse",
  % Name is Prefix ^ "eqb_refl_on_" ^ {coq.gref->id (indc K)},
  % coq.env.add-const Name R Ty @opaque! P,
].

% forall T : Type, T -> list T -> list T --->  forall a eqA, ..R..
% T : Type |- T -> list T -> list T ---> 
pred do-params-refl i:int, i:term, i:term, i:term, o:term.
do-params-refl 0 I T K R :- !, 
  mk-eqb-for I Cmp,
  reali I {{ @eqb_refl_on lp:I lp:Cmp }} => 
  eqb-refl-aux-for I {{ fun x H => H }} => 
  do-args-refl T K R.

do-params-refl NP I (prod N T F) K {{ fun (a : lp:T) (eqA : a -> a -> bool) => lp:(R a eqA) }} :- NP > 0, !, NP1 is NP - 1,
  @pi-decl N T a\
  @pi-decl `eqA` {{ lp:a -> lp:a -> bool }} eqA\
  eqb-for a eqA =>
  eqb-refl-aux-for a {{ fun (x: lp:a) (H : @eqb_refl_on lp:a lp:eqA x) => H }} =>
  reali a {{ @eqb_refl_on lp:a lp:eqA }} =>
    do-params-refl NP1 { coq.mk-app I [a] } (F a) {{ lp:K lp:a }} (R a eqA).


pred do-args-refl i:term, i:term, o:term.
do-args-refl (prod N T F) K {{ fun (x : lp:T) (px : lp:EqbOn x) (h : @eqb_refl_on lp:T lp:Cmp x := lp:View x px) => lp:(R x px h) }} :- !, std.do![
  mk-reali T EqbOn, 
  mk-eqb-for T Cmp,
  eqb-refl-aux-for T View,
  @pi-decl N T x\
  @pi-decl `px` {{ eqb_refl_on lp:Cmp lp:x }} px\
  @pi-def `H` {{ @eqb_refl_on lp:T lp:Cmp lp:x }} {{ lp:View lp:x lp:px }} h\
     do-args-refl (F x) {{ lp:K lp:x }} (R x px h)
].

do-args-refl T K {{ lp:B : eqb_refl_on lp:Cmp lp:K }} :- std.do! [
  coq.safe-dest-app T (global (indt I)) Args,
  tag-for I TagC,
  fields-for I Fields_tC FieldsC _ _,
  coq.mk-app (global (const TagC)) Args Tag,
  coq.mk-app (global (const Fields_tC)) Args Fields_t,
  coq.mk-app (global (const FieldsC)) Args Fields,
  mk-eqb-for T Cmp,
  eqb-fields T EqbFields,
  B = {{ @eqb_body_refl lp:T lp:Tag lp:Fields_t lp:Fields lp:EqbFields lp:K _ }},
  std.assert-ok! (coq.typecheck {{ lp:B (*: eqb_refl_on lp:Cmp lp:K*) }} _) "illtyped",
  coq.ltac.collect-goals B [G] _,
  run-solver G "eqb_refl_on__solver",
].

pred add-indu-refl i:term, i:term, i:term, i:term, i:list term, o:term.
add-indu-refl (prod N T F) I Indu IR LS {{ fun (a : lp:T) (eqA : a -> a -> bool) (eqAc : eqb_reflexive eqA) => lp:(R a eqA eqAc) }} :- !,
  @pi-decl N T a\
  @pi-decl `eqA` {{ lp:a -> lp:a -> bool }} eqA\
  @pi-decl `eqAr` {{ @eqb_reflexive lp:a lp:eqA }} eqAr\ % super nasty "bug", the _ does not see a, if you write lp:{{ FOO a }} it works. Elaborating the skeleton is also ok, but then param1-inhab-db does not work well :-/
  param1-inhab-db {{ @eqb_refl_on lp:a lp:eqA }} eqAr =>
  eqb-for a eqA =>
  add-indu-refl (F a) 
     { coq.mk-app I [a] }
     {{ lp:Indu lp:a (@eqb_refl_on lp:a lp:eqA)}} 
     {{ lp:IR lp:a (@eqb_refl_on lp:a lp:eqA)}} 
     {std.map LS (t\coq.mk-app t [a, eqA])} (R a eqA eqAr).

add-indu-refl _T I Indu IR LS {{ fun x => lp:(R x) }} :- 
  std.assert! (param1-inhab-db IR Is_full) "not trivially inhabited",
  mk-eqb-for I Cmp,  
  @pi-decl `x` _ x\
    std.append LS [x, app[Is_full,x]] (Args x),
    R x = app [Indu, {{ eqb_refl_on lp:Cmp }} | Args x].

pred add-indu-refl-aux i:term, i:term, i:term, i:term, i:list term, o:term.
add-indu-refl-aux (prod N T F) I Indu IR LS {{ fun (a : lp:T) (eqA : a -> a -> bool) => lp:(R a eqA) }} :- !,
  @pi-decl N T a\
  @pi-decl `eqA` {{ lp:a -> lp:a -> bool }} eqA\
  eqb-for a eqA => 
  add-indu-refl-aux (F a) 
     { coq.mk-app I [a] }
     {{ lp:Indu lp:a (@eqb_refl_on lp:a lp:eqA)}} 
     {{ lp:IR lp:a (@eqb_refl_on lp:a lp:eqA)}} 
     {std.map LS (t\coq.mk-app t [a, eqA])} (R a eqA).

add-indu-refl-aux _T I Indu _IR LS R :- std.do![
    mk-eqb-for I Cmp,              
    R = app [Indu, {{ @eqb_refl_on lp:I lp:Cmp}} | LS]
].
}

